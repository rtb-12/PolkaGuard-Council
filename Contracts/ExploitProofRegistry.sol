// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

/**
 * @title ExploitProofRegistry
 * @dev Registry for storing and managing exploit proofs with verification workflow
 */
contract ExploitProofRegistry is Ownable, ReentrancyGuard {
    enum SubmissionStatus {
        Pending,
        Verified,
        Rejected,
        Approved,
        Claimed
    }

    struct Proof {
        address submitter;
        address verifier;
        bytes proofData;
        bytes32[] publicInputs;
        SubmissionStatus status;
        uint256 timestamp;
    }

    uint64 public nextId;
    mapping(uint64 => Proof) public proofs;
    address public bountyVault;

    event ProofSubmitted(
        uint64 indexed id,
        address indexed submitter,
        bytes32 indexed contractAddr
    );

    event ProofVerified(uint64 indexed id, bool result);

    event ProofApproved(uint64 indexed id);

    event BountyClaimed(
        uint64 indexed id,
        address indexed to,
        uint256 amount
    );

    event BountyVaultSet(address indexed vault);

    modifier validProofId(uint64 id) {
        require(id > 0 && id < nextId, "ExploitProofRegistry: invalid proof ID");
        _;
    }

    modifier onlySubmitter(uint64 id) {
        require(
            proofs[id].submitter == msg.sender,
            "ExploitProofRegistry: only submitter can perform this action"
        );
        _;
    }

    constructor() Ownable(msg.sender) {
        nextId = 1;
    }

    /**
     * @dev Set the BountyVault contract address (only owner)
     * @param vaultAddress The address of the BountyVault contract
     */
    function setBountyVault(address vaultAddress) external onlyOwner {
        require(vaultAddress != address(0), "ExploitProofRegistry: zero address");
        bountyVault = vaultAddress;
        emit BountyVaultSet(vaultAddress);
    }

    /**
     * @dev Submit a new exploit proof
     * @param verifier The address of the verifier
     * @param proofData The proof data
     * @param publicInputs Array of public inputs
     * @param contractAddr The contract address being audited
     * @return id The ID of the submitted proof
     */
    function submitProof(
        address verifier,
        bytes calldata proofData,
        bytes32[] calldata publicInputs,
        bytes32 contractAddr
    ) external returns (uint64 id) {
        require(verifier != address(0), "ExploitProofRegistry: zero verifier address");
        require(proofData.length > 0, "ExploitProofRegistry: empty proof data");

        id = nextId++;

        proofs[id] = Proof({
            submitter: msg.sender,
            verifier: verifier,
            proofData: proofData,
            publicInputs: publicInputs,
            status: SubmissionStatus.Pending,
            timestamp: block.timestamp
        });

        emit ProofSubmitted(id, msg.sender, contractAddr);
    }

    /**
     * @dev Verify a submitted proof (can be called by anyone)
     * @param id The ID of the proof to verify
     * @return result The verification result
     */
    function verifyProof(uint64 id) external validProofId(id) returns (bool result) {
        Proof storage proof = proofs[id];
        require(proof.status == SubmissionStatus.Pending, "ExploitProofRegistry: proof not pending");

        // For now, mark as verified (in production, implement actual verification)
        result = true;

        proof.status = result ? SubmissionStatus.Verified : SubmissionStatus.Rejected;
        emit ProofVerified(id, result);
    }

    /**
     * @dev Approve a verified proof (only owner/DAO)
     * @param id The ID of the proof to approve
     */
    function approveProof(uint64 id) external onlyOwner validProofId(id) {
        Proof storage proof = proofs[id];
        require(proof.status == SubmissionStatus.Verified, "ExploitProofRegistry: proof not verified");

        proof.status = SubmissionStatus.Approved;
        emit ProofApproved(id);
    }

    /**
     * @dev Claim bounty for an approved proof (only submitter)
     * @param id The ID of the proof to claim bounty for
     */
    function claimBounty(uint64 id) 
        external 
        validProofId(id) 
        onlySubmitter(id) 
        nonReentrant 
    {
        Proof storage proof = proofs[id];
        require(proof.status == SubmissionStatus.Approved, "ExploitProofRegistry: proof not approved");
        require(bountyVault != address(0), "ExploitProofRegistry: no bounty vault configured");

        proof.status = SubmissionStatus.Claimed;

        // Call BountyVault to withdraw funds
        (bool success, ) = bountyVault.call(
            abi.encodeWithSignature("withdraw(uint64,address)", id, proof.submitter)
        );

        if (!success) {
            // Revert status change if vault call fails
            proof.status = SubmissionStatus.Approved;
            revert("ExploitProofRegistry: failed to withdraw from vault");
        }

        emit BountyClaimed(id, proof.submitter, 0); // Amount determined by vault
    }

    /**
     * @dev Get proof details
     * @param id The ID of the proof
     * @return proof The proof details
     */
    function getProof(uint64 id) external view validProofId(id) returns (Proof memory proof) {
        return proofs[id];
    }

    /**
     * @dev Get bounty vault address
     * @return The address of the bounty vault
     */
    function getBountyVault() external view returns (address) {
        return bountyVault;
    }

    /**
     * @dev Get the current owner (for DAO integration)
     * @return The address of the current owner
     */
    function getOwner() external view returns (address) {
        return owner();
    }

    /**
     * @dev Transfer ownership (useful for DAO integration)
     * @param newOwner The address of the new owner
     */
    function transferOwnership(address newOwner) public override onlyOwner {
        require(newOwner != address(0), "ExploitProofRegistry: new owner is zero address");
        super.transferOwnership(newOwner);
    }

    /**
     * @dev Get proof status
     * @param id The ID of the proof
     * @return status The status of the proof
     */
    function getProofStatus(uint64 id) external view validProofId(id) returns (SubmissionStatus) {
        return proofs[id].status;
    }

    /**
     * @dev Get proof submitter
     * @param id The ID of the proof
     * @return submitter The address of the proof submitter
     */
    function getProofSubmitter(uint64 id) external view validProofId(id) returns (address) {
        return proofs[id].submitter;
    }
}
