#![cfg_attr(not(feature = "std"), no_std, no_main)]

#[ink::contract]
mod exploit_proof_registry {
    use ink::prelude::vec::Vec;
    use ink::storage::Mapping;

    #[ink(storage)]
    pub struct ExploitProofRegistry {
        next_id: u64,
        /// Main storage for all proof data - using Mapping for efficient access
        proofs: Mapping<u64, Proof>,
        owner: AccountId,
        /// BountyVault contract address for fund management
        bounty_vault: Option<AccountId>,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    #[ink::scale_derive(Encode, Decode, TypeInfo)]
    #[cfg_attr(feature = "std", derive(ink::storage::traits::StorageLayout))]
    pub enum SubmissionStatus {
        Pending,
        Verified,
        Rejected,
        Approved,
        Claimed,
    }

    #[derive(Debug, Clone)]
    #[ink::scale_derive(Encode, Decode, TypeInfo)]
    #[cfg_attr(feature = "std", derive(ink::storage::traits::StorageLayout))]
    pub struct Proof {
        submitter: AccountId,
        verifier: AccountId,
        proof: Vec<u8>,
        public_inputs: Vec<Hash>,
        status: SubmissionStatus,
        timestamp: u64,
    }

    #[ink(event)]
    pub struct ProofSubmitted {
        #[ink(topic)]
        id: u64,
        #[ink(topic)]
        submitter: AccountId,
        #[ink(topic)]
        contract_addr: Hash,
    }

    #[ink(event)]
    pub struct ProofVerified {
        #[ink(topic)]
        id: u64,
        result: bool,
    }

    #[ink(event)]
    pub struct ProofApproved {
        #[ink(topic)]
        id: u64,
    }

    #[ink(event)]
    pub struct BountyClaimed {
        #[ink(topic)]
        id: u64,
        #[ink(topic)]
        to: AccountId,
        amount: Balance,
    }

    impl Default for ExploitProofRegistry {
        fn default() -> Self {
            Self::new()
        }
    }

    impl ExploitProofRegistry {
        #[ink(constructor)]
        pub fn new() -> Self {
            Self {
                next_id: 1,
                proofs: Mapping::default(),
                owner: Self::env().caller(),
                bounty_vault: None,
            }
        }

        /// Set the BountyVault contract address (only owner)
        #[ink(message)]
        pub fn set_bounty_vault(&mut self, vault_address: AccountId) {
            assert_eq!(self.env().caller(), self.owner, "Only owner can set vault");
            self.bounty_vault = Some(vault_address);
        }

        /// Auditor calls this to submit proof
        #[ink(message)]
        pub fn submit_proof(
            &mut self,
            verifier: AccountId,
            proof_data: Vec<u8>,
            public_inputs: Vec<Hash>,
            contract_addr: Hash,
        ) -> u64 {
            let id = self.next_id;
            self.next_id = self.next_id.checked_add(1).expect("ID overflow");

            let proof = Proof {
                submitter: Self::env().caller(),
                verifier,
                proof: proof_data,
                public_inputs,
                status: SubmissionStatus::Pending,
                timestamp: Self::env().block_timestamp(),
            };
            self.proofs.insert(id, &proof);
            self.env().emit_event(ProofSubmitted {
                id,
                submitter: proof.submitter,
                contract_addr,
            });
            id
        }

        /// Called by anyone to verify proof on-chain
        #[ink(message)]
        pub fn verify_proof(&mut self, id: u64) -> bool {
            let mut proof = self.proofs.get(id).expect("invalid id");
            assert_eq!(proof.status, SubmissionStatus::Pending);

            // For now, it is marked as verified
            // In production, implement actual verifier contract call
            let result = true;

            proof.status = if result {
                SubmissionStatus::Verified
            } else {
                SubmissionStatus::Rejected
            };
            self.proofs.insert(id, &proof);
            self.env().emit_event(ProofVerified { id, result });
            result
        }

        /// Owner (DAO) approves verified proof
        #[ink(message)]
        pub fn approve_proof(&mut self, id: u64) {
            assert_eq!(self.env().caller(), self.owner);
            let mut proof = self.proofs.get(id).expect("invalid id");
            assert_eq!(proof.status, SubmissionStatus::Verified);
            proof.status = SubmissionStatus::Approved;
            self.proofs.insert(id, &proof);
            self.env().emit_event(ProofApproved { id });
        }

        /// Auditor claims bounty after approval - triggers BountyVault withdrawal
        #[ink(message)]
        pub fn claim_bounty(&mut self, id: u64) {
            let mut proof = self.proofs.get(id).expect("invalid id");
            assert_eq!(proof.status, SubmissionStatus::Approved, "Proof not approved");

            let to = proof.submitter;
            proof.status = SubmissionStatus::Claimed;
            self.proofs.insert(id, &proof);

            // Call BountyVault to withdraw funds
            if let Some(vault_address) = self.bounty_vault {
                let call_result = ink::env::call::build_call::<ink::env::DefaultEnvironment>()
                    .call(vault_address)
                    .transferred_value(0)
                    .exec_input(
                        ink::env::call::ExecutionInput::new(
                            ink::env::call::Selector::new(ink::selector_bytes!("withdraw"))
                        )
                        .push_arg(id)
                        .push_arg(to)
                    )
                    .returns::<()>()
                    .try_invoke();

                match call_result {
                    Ok(Ok(_)) => {
                        self.env().emit_event(BountyClaimed { 
                            id, 
                            to, 
                            amount: 0 // Amount will be determined by vault
                        });
                    }
                    _ => {
                        // Revert the status change if vault call fails
                        proof.status = SubmissionStatus::Approved;
                        self.proofs.insert(id, &proof);
                        panic!("Failed to withdraw from vault");
                    }
                }
            } else {
                panic!("No bounty vault configured");
            }
        }

        /// Remove the internal fund management (delegated to BountyVault)
        /// Get bounty vault address
        #[ink(message)]
        pub fn get_bounty_vault(&self) -> Option<AccountId> {
            self.bounty_vault
        }

        /// Get proof details
        #[ink(message)]
        pub fn get_proof(&self, id: u64) -> Option<Proof> {
            self.proofs.get(id)
        }

        /// Get contract owner
        #[ink(message)]
        pub fn get_owner(&self) -> AccountId {
            self.owner
        }

        /// Transfer ownership (useful for DAO integration)
        #[ink(message)]
        pub fn transfer_ownership(&mut self, new_owner: AccountId) {
            assert_eq!(self.env().caller(), self.owner, "Only owner can transfer ownership");
            self.owner = new_owner;
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[ink::test]
        fn constructor_works() {
            let contract = ExploitProofRegistry::new();
            assert_eq!(contract.get_bounty_vault(), None);
        }

        #[ink::test]
        fn submit_proof_works() {
            let mut contract = ExploitProofRegistry::new();
            let proof_id = contract.submit_proof(
                AccountId::from([0x1; 32]),
                vec![1, 2, 3],
                vec![Hash::from([0x2; 32])],
                Hash::from([0x3; 32]),
            );
            assert_eq!(proof_id, 1);
            
            let proof = contract.get_proof(proof_id).unwrap();
            assert_eq!(proof.status, SubmissionStatus::Pending);
        }
    }
}
